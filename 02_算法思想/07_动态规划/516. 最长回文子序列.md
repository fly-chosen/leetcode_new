### 516. 最长回文子序列

> 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

* 示例 1:

```
输入:

"bbbab"
输出:

4
一个可能的最长回文子序列为 "bbbb"。
```

* 示例 2:

```
输入:

"cbbd"
输出:

2
一个可能的最长回文子序列为 "bb"。
```


#### (动态规划) 最长回文子序列、回文子序列个数
* 1、什么是回文palindrome？
回文指的是正读和反读都一样的字符串，如aba，abba等

* 2、字符子串和字符子序列的区别
   * 字符字串指的是字符串中__连续的__n个字符；如palindrome中，pa，alind，drome等都属于它的字串
   * 字符子序列指的是字符串中__不一定连续但先后顺序一致__的n个字符；如palindrome中，plind，lime属于它的子序列，而mod，rope则不是，因为它们与字符串的字符顺序不一致。

* 3、最长回文子序列
> 要求：
给定字符串，求它的最长回文子序列长度。回文子序列反转字符顺序后仍然与原序列相同。例如字符串abcdfcba中，最长回文子序列长度为7，abcdcba或abcfcba。

#### 思路：
* 动态规划思想

> 对于任意字符串，如果头尾字符相同，那么字符串的最长子序列等于去掉首尾的字符串的最长子序列加上首尾；如果首尾字符不同，则最长子序列等于去掉头的字符串的最长子序列和去掉尾的字符串的最长子序列的较大者。

因此动态规划的状态转移方程为：
* 状态
设字符串为str，长度为n，p[i][j]表示第i到第j个字符间的子序列的个数（i<=j），则：
* 状态转移方程：

```
dp[i][j]=dp[i+1][j-1] + 2  if（str[i]==str[j]）
dp[i][j]=max(dp[i+1][j],dp[i][j-1])  if （str[i]!=str[j]）
```
* 初始化
```dp[i][i]=1 （i=0：n-1）```
* 结果

动态规划代码：
```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] f = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            f[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
}
```
