### 递归实现
> 很多二叉树的题目，用递归写起来就非常简单，这道题就是。

### 再来分析下递归的两个条件：

* 递归终止条件：当节点为空时返回
* 再次递归计算 max( 左节点最大高度，右节点最大高度)+1
* 终止条件很好理解，节点为空了，就返回0，也就是高度为0。
### 关键是第二句，这句可能不好理解。
```
我们看下面这个图，假设节点左边节点这一坨的高度是x，右边节点那一坨的高度是y
我们需要比较X和Y的值谁大，也就是谁的高度更高，假设X这一坨更高。当我们得到了X的值后，还需要 +1。
+1的原因是，我们只得到了X的高度，但是整个树是由根节点，一坨X和一坨Y组成的。所以为了求得整个树的高度，还需要在X的基础上，再加上1，也就多加一个节点(根节点)
```


### 给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
```
* 返回它的最大深度 3 。


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        //如果节点为空，那么深度就是0
		if(root==null) {
			return 0;
		}
		//否则递归的计算  max(左子树的最大深度，右子树的最大深度)
		//不管左子树，右子树是否为空，他们的父节点肯定是不为空
		//所以计算出的总深度要把父节点也要加上，也就是 +1
		return Math.max( maxDepth(root.left), maxDepth(root.right) ) + 1;
}
}
```
